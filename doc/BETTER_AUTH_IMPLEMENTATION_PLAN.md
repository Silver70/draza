# Better Auth + Multi-Tenant Implementation Plan

## Executive Summary

Better Auth has **native multi-tenant support** through its Organizations plugin, which is perfect for your use case. This plan integrates:
- User authentication (email/password + OAuth)
- Multi-tenant organizations (workspaces/companies)
- Role-based access control (owner/admin/member)
- Team invitations
- Tenant context in all API requests

---

## Phase 1: Database Schema Design

### A. Better Auth Tables (Auto-generated by migration)

The Organizations plugin will create these tables:

```typescript
// Core Auth Tables
user                    // Better Auth user table
session                 // Session with activeOrganizationId
account                 // OAuth accounts (optional)
verification            // Email verification tokens

// Organization Tables
organization            // Tenant/workspace/company
├── id (string, PK)
├── name (string)
├── slug (string, unique)
├── logo (string, optional)
├── metadata (json)
└── createdAt (timestamp)

member                  // User-Organization membership
├── id (string, PK)
├── userId (FK → user.id)
├── organizationId (FK → organization.id)
├── role (string: owner/admin/member)
└── createdAt (timestamp)

invitation              // Pending org invitations
├── id (string, PK)
├── email (string)
├── inviterId (FK → user.id)
├── organizationId (FK → organization.id)
├── role (string)
├── status (string)
├── expiresAt (timestamp)
└── createdAt (timestamp)
```

### B. Update Existing Tables (Add tenant_id)

Your existing business tables need `organization_id` for tenant isolation:

```typescript
// Update these tables in your schema
products_table          → add organization_id (FK)
product_variants_table  → add organization_id (FK)
categories_table        → add organization_id (FK)
collections_table       → add organization_id (FK)
customers_table         → add organization_id (FK)
orders_table            → add organization_id (FK)
discounts_table         → add organization_id (FK)
campaigns_table         → add organization_id (FK)
carts_table             → add organization_id (FK)
shipping_methods_table  → add organization_id (FK)
tax_zones_table         → add organization_id (FK)
```

### C. Users vs Customers Clarification

You currently have both `users_table` and `customers_table`. Here's how they'll work:

**Better Auth `user` table:** Staff/admin users who manage the platform
- Can belong to multiple organizations
- Have roles (owner/admin/member)
- Access the admin dashboard

**Your `customers_table`:** End customers who place orders
- Belong to one organization (the merchant)
- Don't have auth access (or separate customer auth if needed later)
- Scoped by organization_id

---

## Phase 2: Backend Implementation

### Step 1: Install Better Auth (Backend)

```bash
cd apps/backend
bun add better-auth
bun add --dev @better-auth/cli
```

### Step 2: Create Auth Configuration

**File:** `apps/backend/src/shared/auth/auth.config.ts`

```typescript
import { betterAuth } from "better-auth"
import { drizzleAdapter } from "better-auth/adapters/drizzle"
import { organization } from "better-auth/plugins"
import { createAccessControl } from "better-auth/plugins/access"
import { db } from "../db"

export const auth = betterAuth({
  database: drizzleAdapter(db, {
    provider: "pg"
  }),

  emailAndPassword: {
    enabled: true,
    requireEmailVerification: true,
    sendVerificationEmail: async ({ user, url }) => {
      // TODO: Send email with verification link
      console.log(`Verification email to ${user.email}: ${url}`)
    }
  },

  plugins: [
    organization({
      // Organization creation settings
      allowUserToCreateOrganization: true,
      organizationLimit: 5, // Max orgs per user
      creatorRole: "owner",

      // Member settings
      membershipLimit: 50, // Max members per org

      // Invitation settings
      invitationExpiresIn: 60 * 60 * 24 * 7, // 7 days
      sendInvitationEmail: async (data) => {
        const inviteLink = `${process.env.FRONTEND_URL}/accept-invitation/${data.id}`
        // TODO: Send invitation email
        console.log(`Invite ${data.email} to join: ${inviteLink}`)
      },

      // Custom roles with permissions
      ac: createAccessControl({
        product: ["create", "read", "update", "delete"],
        order: ["create", "read", "update", "delete", "refund"],
        customer: ["create", "read", "update", "delete"],
        discount: ["create", "read", "update", "delete"],
        campaign: ["create", "read", "update", "delete"],
        analytics: ["read"],
        settings: ["read", "update"]
      }),

      roles: {
        owner: {
          product: ["create", "read", "update", "delete"],
          order: ["create", "read", "update", "delete", "refund"],
          customer: ["create", "read", "update", "delete"],
          discount: ["create", "read", "update", "delete"],
          campaign: ["create", "read", "update", "delete"],
          analytics: ["read"],
          settings: ["read", "update"]
        },
        admin: {
          product: ["create", "read", "update", "delete"],
          order: ["create", "read", "update", "delete", "refund"],
          customer: ["create", "read", "update", "delete"],
          discount: ["create", "read", "update", "delete"],
          campaign: ["create", "read", "update", "delete"],
          analytics: ["read"],
          settings: ["read"]
        },
        member: {
          product: ["read"],
          order: ["read"],
          customer: ["read"],
          analytics: ["read"]
        }
      }
    })
  ],

  // Session configuration
  session: {
    expiresIn: 60 * 60 * 24 * 7, // 7 days
    updateAge: 60 * 60 * 24 // Update every 24 hours
  }
})
```

### Step 3: Generate Database Migration

```bash
cd apps/backend
bunx @better-auth/cli generate
bunx drizzle-kit push
```

### Step 4: Create Auth Routes

**File:** `apps/backend/src/modules/auth/auth.routes.ts`

```typescript
import { Hono } from 'hono'
import { auth } from '../../shared/auth/auth.config'

export const authRoutes = new Hono()

// Mount all Better Auth endpoints
authRoutes.on(['GET', 'POST'], '/*', (c) => {
  return auth.handler(c.req.raw)
})
```

### Step 5: Create Auth Middleware

**File:** `apps/backend/src/shared/middleware/auth.middleware.ts`

```typescript
import { auth } from '../auth/auth.config'
import type { Context, Next } from 'hono'

export interface AuthContext {
  user: {
    id: string
    email: string
    name: string
  }
  session: {
    id: string
    activeOrganizationId: string | null
  }
  organization: {
    id: string
    name: string
    role: 'owner' | 'admin' | 'member'
  } | null
}

// Require authenticated user
export async function requireAuth(c: Context, next: Next) {
  const session = await auth.api.getSession({
    headers: c.req.raw.headers
  })

  if (!session) {
    return c.json({ error: 'Unauthorized' }, 401)
  }

  c.set('authContext', {
    user: session.user,
    session: session.session,
    organization: null // Set by requireOrganization
  })

  await next()
}

// Require active organization
export async function requireOrganization(c: Context, next: Next) {
  await requireAuth(c, async () => {})

  const authContext = c.get('authContext') as AuthContext
  const activeOrgId = authContext.session.activeOrganizationId

  if (!activeOrgId) {
    return c.json({ error: 'No active organization' }, 400)
  }

  // Get user's membership in this org
  const member = await auth.api.getActiveMember({
    headers: c.req.raw.headers,
    body: { organizationId: activeOrgId }
  })

  if (!member) {
    return c.json({ error: 'Not a member of this organization' }, 403)
  }

  authContext.organization = {
    id: activeOrgId,
    name: member.organization.name,
    role: member.role as 'owner' | 'admin' | 'member'
  }

  c.set('authContext', authContext)
  await next()
}

// Require specific permissions
export function requirePermissions(resource: string, actions: string[]) {
  return async (c: Context, next: Next) => {
    await requireOrganization(c, async () => {})

    const hasPermission = await auth.api.hasPermission({
      headers: c.req.raw.headers,
      body: {
        permissions: { [resource]: actions }
      }
    })

    if (!hasPermission) {
      return c.json({ error: 'Insufficient permissions' }, 403)
    }

    await next()
  }
}
```

### Step 6: Create Tenant Context Middleware

**File:** `apps/backend/src/shared/middleware/tenant.middleware.ts`

```typescript
import type { Context, Next } from 'hono'
import type { AuthContext } from './auth.middleware'

// Inject organization_id into request context
export async function injectTenantContext(c: Context, next: Next) {
  const authContext = c.get('authContext') as AuthContext

  if (authContext?.organization) {
    c.set('organizationId', authContext.organization.id)
  }

  await next()
}

// Helper to get organization ID from context
export function getOrganizationId(c: Context): string {
  const orgId = c.get('organizationId')
  if (!orgId) {
    throw new Error('Organization context not available')
  }
  return orgId
}
```

### Step 7: Update Main App Entry Point

**File:** `apps/backend/src/index.ts`

```typescript
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { authRoutes } from './modules/auth/auth.routes'
import { productsRoutes } from './modules/products/products.routes'
import { ordersRoutes } from './modules/orders/orders.routes'
import { customersRoutes } from './modules/customers/customers.route'
import { taxRoutes } from './modules/orders/tax.routes'
import { analyticsRoutes } from './modules/analytics/analytics.routes'
import { discountsRoutes } from './modules/discounts/discounts.routes'
import { cartRoutes } from './modules/cart/cart.routes'
import { requireOrganization } from './shared/middleware/auth.middleware'
import { injectTenantContext } from './shared/middleware/tenant.middleware'

const app = new Hono()

// CORS (update to include credentials)
app.use('/*', cors({
  origin: ['http://localhost:3001', 'http://localhost:3002', 'http://localhost:5173'],
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowHeaders: ['Content-Type', 'Authorization'],
  exposeHeaders: ['Content-Length'],
  maxAge: 600,
  credentials: true,
}))

// Public routes
app.get('/', (c) => c.text('Hello Hono!'))
app.route('/auth', authRoutes) // Public auth endpoints

// Protected routes (require org context)
app.use('/products/*', requireOrganization, injectTenantContext)
app.use('/orders/*', requireOrganization, injectTenantContext)
app.use('/customers/*', requireOrganization, injectTenantContext)
app.use('/tax/*', requireOrganization, injectTenantContext)
app.use('/analytics/*', requireOrganization, injectTenantContext)
app.use('/discounts/*', requireOrganization, injectTenantContext)
app.use('/cart/*', requireOrganization, injectTenantContext)

app.route('/products', productsRoutes)
app.route('/orders', ordersRoutes)
app.route('/customers', customersRoutes)
app.route('/tax', taxRoutes)
app.route('/analytics', analyticsRoutes)
app.route('/discounts', discountsRoutes)
app.route('/cart', cartRoutes)

export default app
```

### Step 8: Update Repository Layer (Example)

**File:** `apps/backend/src/modules/products/repo/products.repo.ts`

```typescript
import { db } from '../../../shared/db'
import { productsTable } from '../../../shared/db/schema'
import { eq, and } from 'drizzle-orm'

// Before: No tenant filtering
export async function getAllProducts() {
  return await db.select().from(productsTable)
}

// After: Filtered by organization
export async function getAllProducts(organizationId: string) {
  return await db
    .select()
    .from(productsTable)
    .where(eq(productsTable.organization_id, organizationId))
}

export async function getProductById(id: string, organizationId: string) {
  const [product] = await db
    .select()
    .from(productsTable)
    .where(
      and(
        eq(productsTable.id, id),
        eq(productsTable.organization_id, organizationId)
      )
    )
  return product
}

export async function createProduct(data: any, organizationId: string) {
  const [product] = await db
    .insert(productsTable)
    .values({
      ...data,
      organization_id: organizationId
    })
    .returning()
  return product
}
```

### Step 9: Update Route Handlers (Example)

**File:** `apps/backend/src/modules/products/products.routes.ts`

```typescript
import { Hono } from 'hono'
import { zValidator } from '@hono/zod-validator'
import { getAllProducts, createProduct } from './repo/products.repo'
import { getOrganizationId } from '../../shared/middleware/tenant.middleware'
import { requirePermissions } from '../../shared/middleware/auth.middleware'

export const productsRoutes = new Hono()

// GET /products - Read permission
productsRoutes.get('/',
  requirePermissions('product', ['read']),
  async (c) => {
    const organizationId = getOrganizationId(c)
    const products = await getAllProducts(organizationId)
    return c.json({ success: true, data: products })
  }
)

// POST /products - Create permission
productsRoutes.post('/',
  requirePermissions('product', ['create']),
  zValidator('json', createProductSchema),
  async (c) => {
    const organizationId = getOrganizationId(c)
    const data = c.req.valid('json')
    const product = await createProduct(data, organizationId)
    return c.json({ success: true, data: product })
  }
)
```

---

## Phase 3: Frontend Implementation

### Step 1: Install Better Auth (Frontend)

```bash
cd apps/frontend
bun add better-auth
```

### Step 2: Create Auth Client

**File:** `apps/frontend/src/lib/auth.client.ts`

```typescript
import { createAuthClient } from "better-auth/client"
import { organizationClient } from "better-auth/client/plugins"

export const authClient = createAuthClient({
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:3000',
  plugins: [organizationClient()]
})
```

### Step 3: Create Auth Context

**File:** `apps/frontend/src/contexts/AuthContext.tsx`

```typescript
import React, { createContext, useContext, useState, useEffect } from 'react'
import { authClient } from '~/lib/auth.client'

interface User {
  id: string
  email: string
  name: string
}

interface Organization {
  id: string
  name: string
  slug: string
  role: 'owner' | 'admin' | 'member'
}

interface AuthContextType {
  user: User | null
  organization: Organization | null
  organizations: Organization[]
  isLoading: boolean
  login: (email: string, password: string) => Promise<void>
  logout: () => Promise<void>
  switchOrganization: (orgId: string) => Promise<void>
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [organization, setOrganization] = useState<Organization | null>(null)
  const [organizations, setOrganizations] = useState<Organization[]>([])
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    checkAuth()
  }, [])

  async function checkAuth() {
    try {
      const session = await authClient.getSession()
      if (session?.data) {
        setUser(session.data.user)

        // Get organizations
        const orgs = await authClient.organization.listOrganizations()
        setOrganizations(orgs.data || [])

        // Get active organization
        const activeOrg = await authClient.organization.getActiveOrganization()
        if (activeOrg?.data) {
          const member = await authClient.organization.getActiveMember({})
          setOrganization({
            ...activeOrg.data,
            role: member?.data?.role || 'member'
          })
        }
      }
    } catch (error) {
      console.error('Auth check failed:', error)
    } finally {
      setIsLoading(false)
    }
  }

  async function login(email: string, password: string) {
    await authClient.signIn.email({ email, password })
    await checkAuth()
  }

  async function logout() {
    await authClient.signOut()
    setUser(null)
    setOrganization(null)
    setOrganizations([])
  }

  async function switchOrganization(orgId: string) {
    await authClient.organization.setActive({ organizationId: orgId })
    await checkAuth()
  }

  return (
    <AuthContext.Provider value={{
      user,
      organization,
      organizations,
      isLoading,
      login,
      logout,
      switchOrganization
    }}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider')
  }
  return context
}
```

### Step 4: Create Centralized API Client

**File:** `apps/frontend/src/lib/apiClient.ts`

```typescript
import axios from 'redaxios'
import { authClient } from './auth.client'

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000'

const apiClient = axios.create({
  baseURL: API_BASE_URL,
  withCredentials: true // Important for cookies
})

// Add auth headers to every request
apiClient.interceptors.request.use(async (config) => {
  const session = await authClient.getSession()
  if (session?.data?.session) {
    // Better Auth uses cookies, but you can add Bearer token if needed
    config.headers = config.headers || {}
  }
  return config
})

// Handle 401 errors
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Redirect to login
      window.location.href = '/login'
    }
    return Promise.reject(error)
  }
)

export default apiClient
```

### Step 5: Update All API Utils

**Update all 10 files in `apps/frontend/src/utils/*.ts`:**

```typescript
// Change from:
import axios from 'redaxios'
const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000'

// To:
import apiClient from '~/lib/apiClient'

// Then replace all axios.get/post/put/delete with apiClient.get/post/put/delete
// Example:
export const fetchProducts = createServerFn({ method: 'GET' }).handler(
  async () => {
    const response = await apiClient.get<ProductsResponse>('/products')
    // ... rest of code
  }
)
```

### Step 6: Update Root Layout

**File:** `apps/frontend/src/routes/__root.tsx`

```typescript
import { AuthProvider } from '~/contexts/AuthContext'
import { ThemeProvider } from '~/components/theme-provider'

function RootDocument({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <head>
        <HeadContent />
        {/* ... existing script ... */}
      </head>
      <body>
        <AuthProvider>
          <ThemeProvider defaultTheme="system" defaultColorScheme="default">
            <SidebarProvider>
              <AppSidebar />
              {children}
            </SidebarProvider>
            <Toaster richColors position="top-right" />
          </ThemeProvider>
        </AuthProvider>
        <Scripts />
      </body>
    </html>
  )
}
```

### Step 7: Create Login Page

**File:** `apps/frontend/src/routes/login.tsx`

```typescript
import { createFileRoute, useRouter } from '@tanstack/react-router'
import { useState } from 'react'
import { useAuth } from '~/contexts/AuthContext'
import { Button } from '~/components/ui/button'
import { Input } from '~/components/ui/input'
import { Label } from '~/components/ui/label'

export const Route = createFileRoute('/login')({
  component: LoginPage
})

function LoginPage() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [error, setError] = useState('')
  const { login } = useAuth()
  const router = useRouter()

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault()
    try {
      await login(email, password)
      router.navigate({ to: '/' })
    } catch (err) {
      setError('Invalid email or password')
    }
  }

  return (
    <div className="flex min-h-screen items-center justify-center">
      <div className="w-full max-w-md space-y-8 p-8">
        <h1 className="text-2xl font-bold">Login</h1>

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <Label htmlFor="email">Email</Label>
            <Input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
            />
          </div>

          <div>
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </div>

          {error && <p className="text-red-500 text-sm">{error}</p>}

          <Button type="submit" className="w-full">
            Login
          </Button>
        </form>
      </div>
    </div>
  )
}
```

### Step 8: Protect Routes

**Add to each protected route file:**

```typescript
import { redirect } from '@tanstack/react-router'
import { authClient } from '~/lib/auth.client'

export const Route = createFileRoute('/products/')({
  beforeLoad: async ({ context }) => {
    const session = await authClient.getSession()
    if (!session?.data) {
      throw redirect({ to: '/login' })
    }
  },
  component: ProductsPage
})
```

### Step 9: Create Organization Switcher

**File:** `apps/frontend/src/components/OrganizationSwitcher.tsx`

```typescript
import { useAuth } from '~/contexts/AuthContext'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '~/components/ui/select'

export function OrganizationSwitcher() {
  const { organization, organizations, switchOrganization } = useAuth()

  return (
    <Select
      value={organization?.id}
      onValueChange={switchOrganization}
    >
      <SelectTrigger className="w-[200px]">
        <SelectValue placeholder="Select organization" />
      </SelectTrigger>
      <SelectContent>
        {organizations.map((org) => (
          <SelectItem key={org.id} value={org.id}>
            {org.name}
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  )
}
```

---

## Phase 4: Database Migration Strategy

### Schema Updates

**File:** `apps/backend/src/shared/db/catalogue.ts`

```typescript
// Add to all tables:
export const productsTable = pgTable('products_table', {
  // ... existing fields
  organization_id: text('organization_id').notNull(), // Add this
  // ... rest
})
```

**Repeat for all tables:**
- `product_variants_table`
- `categories_table`
- `collections_table`
- `orders_table`
- `customers_table`
- `discounts_table`
- `campaigns_table`
- `carts_table`
- `tax_zones_table`
- `shipping_methods_table`

### Migration Steps

```bash
# 1. Better Auth tables
bunx @better-auth/cli generate
bunx drizzle-kit push

# 2. Add organization_id columns
bunx drizzle-kit generate
bunx drizzle-kit push

# 3. Create seed organization for existing data
# apps/backend/seed-default-org.ts
```

---

## Phase 5: Implementation Checklist

### Backend Tasks:
- [ ] Install Better Auth + CLI
- [ ] Create auth config with Organizations plugin
- [ ] Generate Better Auth migrations
- [ ] Create auth routes
- [ ] Create auth middleware (requireAuth, requireOrganization)
- [ ] Create tenant context middleware
- [ ] Update main app.ts with middleware
- [ ] Add `organization_id` to all schema tables
- [ ] Generate schema migrations
- [ ] Update all repository functions (add organizationId param)
- [ ] Update all route handlers (extract organizationId from context)
- [ ] Add permission checks to sensitive endpoints
- [ ] Create seed script for default organization
- [ ] Test auth flow

### Frontend Tasks:
- [ ] Install Better Auth client
- [ ] Create auth client config
- [ ] Create AuthContext provider
- [ ] Create centralized API client with credentials
- [ ] Update all 10 API utility files (replace axios import)
- [ ] Wrap root layout with AuthProvider
- [ ] Create login page
- [ ] Create signup page (optional)
- [ ] Create organization switcher component
- [ ] Add route protection (beforeLoad hooks)
- [ ] Add organization switcher to sidebar/header
- [ ] Create invitation acceptance page
- [ ] Test auth flow

---

## Estimated Timeline

| Phase | Time Estimate |
|-------|--------------|
| Phase 1: Database Design | 1-2 hours |
| Phase 2: Backend Implementation | 8-12 hours |
| Phase 3: Frontend Implementation | 6-8 hours |
| Phase 4: Database Migration | 2-3 hours |
| Phase 5: Testing & Bug Fixes | 4-6 hours |
| **Total** | **21-31 hours** |

---

## Key Benefits of This Approach

✅ **Native Multi-Tenancy** - Organizations plugin handles everything
✅ **Type-Safe** - Full TypeScript support
✅ **Drizzle Integration** - Uses your existing ORM
✅ **RBAC Built-in** - Owner/Admin/Member roles with custom permissions
✅ **Invitation System** - Built-in email invitations
✅ **Session Management** - Cookie-based auth (SSR compatible)
✅ **Free & Self-Hosted** - No external service costs
✅ **Active Development** - Better Auth is actively maintained

---

## Resources & Documentation

- [Better Auth](https://www.better-auth.com/)
- [Organizations | Better Auth UI](https://better-auth-ui.com/advanced/organizations)
- [Organization | Better Auth](https://www.better-auth.com/docs/plugins/organization)
- [When Embedded AuthN Meets Embedded AuthZ - Building Multi-Tenant Apps With Better-Auth and ZenStack | ZenStack](https://zenstack.dev/blog/better-auth)
- [Building (Better Auth) in Fastify: Multi-Tenant SaaS and Secure API Authentication](https://peerlist.io/shrey_/articles/building-better-auth-in-fastify-multitenant-saas-and-secure-api-authentication)

---

## File Change Summary

### Files to Create (Backend):
1. `apps/backend/src/shared/auth/auth.config.ts`
2. `apps/backend/src/modules/auth/auth.routes.ts`
3. `apps/backend/src/shared/middleware/auth.middleware.ts`
4. `apps/backend/src/shared/middleware/tenant.middleware.ts`

### Files to Modify (Backend):
1. `apps/backend/src/index.ts` - Add auth routes + middleware
2. `apps/backend/package.json` - Add Better Auth dependency
3. `apps/backend/.env` - Add configuration
4. All schema files in `apps/backend/src/shared/db/` - Add organization_id
5. All repo files (7 modules) - Add organizationId parameter
6. All route files (7 modules) - Extract organizationId from context

**Total backend files touched: ~30-35 files**

### Files to Create (Frontend):
1. `apps/frontend/src/lib/auth.client.ts`
2. `apps/frontend/src/contexts/AuthContext.tsx`
3. `apps/frontend/src/lib/apiClient.ts`
4. `apps/frontend/src/routes/login.tsx`
5. `apps/frontend/src/routes/auth/callback.tsx`
6. `apps/frontend/src/components/OrganizationSwitcher.tsx`

### Files to Modify (Frontend):
1. All 10 API utility files in `apps/frontend/src/utils/` - Update imports
2. `apps/frontend/src/routes/__root.tsx` - Add AuthProvider
3. `apps/frontend/package.json` - Add Better Auth dependency
4. All route files - Add beforeLoad protection
5. `apps/frontend/.env` - Add configuration

**Total frontend files touched: ~20-25 files**

---

## Notes & Considerations

### Security Considerations:
- All API endpoints require authentication by default
- Organization context is required for all business operations
- Permission checks can be granular (per-resource, per-action)
- Session cookies are httpOnly and secure
- CSRF protection via Better Auth

### Data Isolation:
- Every query must filter by `organization_id`
- Middleware automatically injects organization context
- Helper function `getOrganizationId(c)` ensures context is available
- Database constraints prevent cross-tenant data access

### Scalability:
- Better Auth supports horizontal scaling
- Session data can be stored in database or Redis
- Organization switching is instant (no page reload)
- Lazy loading of organization data

### Migration Strategy:
- Create a default organization for existing data
- Backfill `organization_id` for all existing records
- Run migrations in stages (auth tables first, then business tables)
- Test with a subset of data before full migration
